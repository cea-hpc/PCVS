#!/usr/bin/perl

#should not remote this :)
use strict;
use warnings;

use 5.010;
use English qw( -no_match_vars );
use Pod::Usage;

###########################################################################
#### main vars
###########################################################################
my %gconf;
my $srcdir;
my $internaldir;
my $buildir;

###########################################################################
#### COMPILATION TIME
###########################################################################
BEGIN {
	# this is used to dynamically set Perl module path.
	$srcdir = `readlink -e \`dirname $0\``; chomp $srcdir;
	$internaldir = $srcdir."/build_scripts";
}

#third-party libs loading
use lib "$srcdir/build_scripts/modules";

# dep inclusions
use PCVS::Helper;           # PCVS Helper (path cleaning...)
use PCVS::Configuration;    # PCVS Configuration handler (loading...)
use PCVS::TEngine;          # PCVS TE engine
use File::Tee "tee";        # get the output sync'd w/ a file
use File::chdir;            # Change directory (to build JCHRONOSS)
use File::Path qw(mkpath);  # Path modifiers
use File::Copy::Recursive qw(fcopy dircopy pathempty); #Copy routines
use Getopt::Long;           # Parsing options
use Sys::Hostname;          # Hostname getter
use Data::Dumper;           # Help printing data structures (could be removed)

###########################################################################
#### FUNCTIONS
###########################################################################
# Just print PVS header at validation start
# Args: No Args
sub print_summary
{
	my $config_target = "\'default\'";
	$config_target .= " & \'$gconf{'config-target'}\'" if(exists $gconf{'config-target'});
	print "\n >>>>>>>>>>>>>>>>>>>>> GLOBAL INFOS (see \$buildir/config.yml) <<<<<<<<<<<<<<<<<<\n";
	print "      - Run Start date   : ".localtime()."\n";
	print "      - Host name        : ".hostname."\n";
	print "      - Source directory : $gconf{'src'}\n";
	print "      - Build directory  : $gconf{'build'}\n";
	print "      - Loaded Config.   : $config_target\n";
	print "      - Loaded Runtime   : \'$gconf{'runtime'}{'target'}\'\n";
	print "      - Loaded Compiler  : \'$gconf{'compiler'}{'target'}\'\n";
	print "      - Loaded Group File: \'$gconf{'group-target'}\'\n";
	print "      - Test directories : ".join(", ", @{ $gconf{'select'} } )."\n";
}

###########################################################################
# Dump data from current environment and log it to $buildir/env.log
# You can add here anything you want to be included
# Args: No Args
sub env_logging
{
	open(my $fh, ">", "$buildir/env.log");
	print $fh "\n#####################\n# GENERAL INFOS \n#####################\n";
	print $fh "Uptime: ".`uptime`;
	print $fh "\n#####################\n# LOADED MODULES \n#####################\n";
	print $fh `module list 2> /dev/null`;
	print $fh "\n#####################\n# ENVIRONMENT VARS \n#####################\n";
	print $fh `env`;
	print $fh "\n#####################\n# COMPILERS \n#####################\n";
	foreach(('c', 'cxx', 'f77', 'f90', 'f95', 'f03', 'f08'))
	{
		my $cur = $gconf{compiler}{$_};
		if(defined $cur)
		{
			print $fh "$_ found at ".`which $cur`;
		}
	}
	print $fh "Extra flags: '$gconf{compiler}{cflags}'\n";
	print $fh "OpenMP support: '$gconf{compiler}{openmp}'\n";
	print $fh "TBB support: '$gconf{compiler}{tbb}'\n";

	print $fh "\n#####################\n# RUNTIME \n#####################\n";
	if(exists $gconf{runtime}{cmd} and $gconf{runtime}{cmd} ne '')
	{
		print $fh "Runtime launcher found at ".`which $gconf{runtime}{cmd}`;
	}
	print $fh "Perl module to validate: $gconf{runtime}{module}\n";
	close($fh);
}

###########################################################################
# Catch Ctrl-C and transmit it to child processes
# Args: No Args
sub trap_signal
{
	print "Stopped by receiving a signal.\n";
	#my @process_list = grep(/[0-9]*/, `ps -o ppid=$$ | sort | uniq`);
	#if(scalar @process_list)
	#{
	#kill('KILL', @process_list);
	#}
	exit(127);
}

###########################################################################
# clean up sensible paths contained in an path. This is done just before
# creating the tarball. This function replaces : 
# - $srcdir    -> $PCVS_SOURCE_DIR
# - $buildir   -> $PCVS_BUILD_DIR
# - $HOME      -> $PCVS_USER_HOME
# - $USER      -> $PCVS_USER_LOGIN
# - $HOSTNAME  -> $PCVS_HOST_NAME
# Args:
#    - $path : the path to clean up
sub anonymize_archive
{
	my ($path) = @_;

	my %bad_patterns = ( 
		$srcdir         => "\\\$PCVS_SOURCE_DIR", 
		$buildir        => "\\\$PCVS_BUILD_DIR", 
		$ENV{'HOME'}    => "\\\$PCVS_USER_HOME", 
		$ENV{'LOGNAME'} => "\\\$PCVS_USER_LOGIN",
		(hostname)      => "\\\$PCVS_HOST_NAME"
	);

	foreach my $pat(keys %bad_patterns)
	{
		my $old = $pat;
		my $new = $bad_patterns{$pat};

		# 1. EGREP finds files matching pattern and returns the list of matching files (-l option)
		# 2. perl -pie makes in-place replacement.
		# (Could be replace by a while() loop instead of calling a extern process
		my @matching_list = `egrep -ril \"$old\" $path`; chomp @matching_list;
		if(@matching_list ne 0)
		{
			system("perl -p -i -e 's,$old,$new,g' ".join(" ", @matching_list));
		}
	}

}


###########################################################################
# Prepare the validation to be processed. Main point here is to compile JCHRONOSS
# Args: No Args
sub run_prepare
{
	print "\n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PRE-RUN STEP <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
	#copy the webview in target dir
	print ' * Building the Webview (reachable at $buildir/webview//index.html)'."\n";
	dircopy("$internaldir/generation/jchronoss/tools/webview/*", "$buildir/") or die("Unable to copy the webview: $!");
	my $var = `$buildir/webview_gen_all.sh --skeleton`;
	#copy jsloc
	print " * Saving JsLoc into build directory.\n";
	dircopy("$internaldir/generation/jchronoss/tools/jsLoc/*", "$buildir/") or die("Unable to copy JsLoc: $!");

	#build JCHRONOSS
	print " * Building JCHRONOSS\n";
	helper_clean_path("$buildir/tmp/build", 0);
	{
		local $CWD = "$buildir/tmp/build"; # equivalent to chdir()
		my $color = "";
		($color = "-DENABLE_COLOR=".($gconf{"color"} == 1 ? "ON" : "OFF")) if (exists $gconf{"color"});
		system("cmake $internaldir/generation/jchronoss -DENABLE_OPENMP=OFF -DCMAKE_INSTALL_PREFIX=$buildir/tmp $color && make install");
		die("Error during JCHRONOSS compilation !") if(($? >> 8) != 0);


	}
	helper_clean_path("$buildir/tmp/traces", 1);

	env_logging();
}

###########################################################################
# After the validation, prepare the tarball by copying needed data from build_scripts to $buildir
# Args: No Args
sub run_finalize
{

	print "\n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> POST-RUN STEP <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
	#remove colors sequences
	#copy banners
	dircopy("$internaldir/resources/banners", "$buildir/banners");

	#generate tarball
	unlink("$buildir/last_results.tar.gz");

	#copy needed data into the future archive
	helper_clean_path("$buildir/last_results", 1);
	dircopy("$internaldir/resources/banners", "$buildir/last_results/banners");
	dircopy("$buildir/webview", "$buildir/last_results/webview") or die("Unable to save the webview in the archive !");
	fcopy("$buildir/webview_gen_all.sh", "$buildir/last_results/") or die("Unable to copy webview_gen_all.sh !");
	dircopy("$buildir/jsLoc", "$buildir/last_results/jsLoc") or die("Unable to save JsLoc in the archive !");
	fcopy("$buildir/jsLoc_gen_all.sh", "$buildir/last_results/jsLoc_gen_all.sh") or die("Unable to save JsLoc_gen_all.sh in the archive !");
	fcopy("$buildir/config.yml", "$buildir/last_results/") or die ("Unable to save the configuration file !");
	fcopy("$buildir/config.env", "$buildir/last_results/") or die ("Unable to save the environment file !");
	dircopy("$buildir/tmp/traces", "$buildir/last_results/") or die ("Unable to copy trace files !");

	# find XML output files
	helper_clean_path("$buildir/last_results/test_suite", 1);
	{
		local $CWD = "$buildir/last_results/test_suite/";
		my @list_files = `find $buildir/test_suite/ -iname 'output*.xml' 2> /dev/null`; chomp @list_files;
		foreach my $res_file(@list_files)
		{
			(my $new_path = $res_file) =~ s,$buildir,$buildir/last_results,;
			my $path = `dirname $new_path`; chomp $path;

			mkpath($path) if (! -d $path);
			fcopy($res_file, $path);
		}
	}

	print " * End Date : ".localtime()."\n";
	fcopy("$buildir/output.log", "$buildir/last_results/") if(!exists $gconf{'log'} || $gconf{'log'});
	fcopy("$buildir/env.log", "$buildir/last_results/") or die ("Unable to save the environment logfile !");

	anonymize_archive("$buildir/last_results");

	print " * Creating the archive (located at $buildir/last_results.tar.gz)\n";
	{
		local $CWD = $buildir;
		`tar -czf $buildir/last_results.tar.gz last_results`;
	}
}

###########################################################################
# Load test configurations and build associated XML files
# Args: No Args
sub run_configure
{
	print "\n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BUILD STEP <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
	engine_init(\%gconf);

	#we put this here, because engine_init unrolls system iterator values.
	#we can't move engine_init() earlier, beacuse of --noregen option
	configuration_save();

	helper_clean_path("$buildir/test_suite", 1);
	
	# Loads group info into a string, lately printed in each pcvs.yml.in
	my $grp_stream;
	{
		local $/ = undef;
		open (my $f, "<", "$internaldir/configuration/groups/$gconf{'group-target'}.yml") or die ("Could not open groups file $gconf{'group-target'} !");
		$grp_stream = <$f>;
		close $f;
	}

	print " * Building the list of tests:\n";
	my $istart=time();
	
	#for each desired subdirectory
	foreach my $directory (@{ $gconf{'select'}})
	{
		my $current_path = "$srcdir/$directory";
		#Clean the complete directory (the simplest..)
		helper_clean_path("$buildir/test_suite/$directory", 1);
		my @current_list = `find $current_path -name "pcvs.setup"`; chomp @current_list;

		# Iterates over each pcvs.setup file
		foreach my $setup_elem(@current_list)
		{
			#find the associated subtree
			$setup_elem =~ s/\/pcvs.setup$//;
			(my $name = $setup_elem) =~ s/$srcdir\///g;
			my $current_bpath = "$buildir/test_suite/$name";

			# create the tree if it does not exist yet (no cleanups)
			helper_clean_path("$current_bpath", 0);
			
			print "    - Setup $name\n";
			my $override_file = `. $buildir/config.env && $setup_elem/pcvs.setup $name`;
			die("$name Setup failed !") if (($? >> 8) != 0);

			# if pcvs.setup produces a content, echo it to build pcvs.yml.in and prepends it 'group' content
			if($override_file ne "")
			{
				open(my $ofh, ">", "$current_bpath/pcvs.yml.in") or die ("Error in $current_bpath: $!");
				print $ofh $grp_stream;
				print $ofh  $override_file;
				close($ofh);
			}

		}

		# as pcvs.setup can create some YAML file in work dir, we look for these files in both source and work directories
		@current_list = `find $current_path $buildir/test_suite/$directory -name "pcvs.yml.in" 2>/dev/null`; chomp @current_list;
		foreach my $yaml_elem(@current_list)
		{
			# find the test subtree
			$yaml_elem =~ s/\/pcvs.yml.in$//;
			(my $name = $yaml_elem) =~ s/($buildir\/test_suite|$srcdir)\///g;
			my $current_bpath = "$buildir/test_suite/$name";
			my $current_path = "$srcdir/$name";

			# create the tree if it does not exist yet (no cleanups)
			helper_clean_path("$current_bpath", 0);
		
			# if pcvs.setup does not already create a file, copy the .in file 
			if(! -f "$current_bpath/pcvs.yml.in")
			{
				open (my $w, ">", "$current_bpath/pcvs.yml.in") or die("Unable to open $current_bpath/pcvs.yml.in: $!");
				print $w $grp_stream; # we have to append this
				print $w `cat $yaml_elem/pcvs.yml.in`;
				close $w;
			}
			
			# Replace @...@ by real paths (files are in $buildir). Lazy macro processing. Maybe we could do it before copying it
			system("cat $current_bpath/pcvs.yml.in | sed -e 's,\@SRCPATH\@,$current_path,g' -e 's,\@BUILDPATH\@,$current_bpath,g' > $current_bpath/pcvs.yml");

			#Where things are going to be done (TE un-rolling)
			print "    - Generate $name\n";
			engine_unfold_file($current_bpath, $name, "$current_bpath/pcvs.yml");
		}
	}
	print " * Validation tree built in ".(time()-$istart)." second(s)\n";
	engine_fini();
}

###########################################################################
# Run JCHRONOSS with the list of registered XML files
# Args: No Args
sub run_exec
{	
	print "\n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RUN STEP <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
	my ($nb_resources, $nb_workers, $compil_w, $run_w, $autokill, $wlist, $blist, $verbosity, $policy, $maxjobt, $max_workert, $min_workert, $rc_on_fail, $test_files) = ();

	$nb_resources = $gconf{'cluster'}{'max_nodes'} || 1;
	$nb_workers = $gconf{'validation'}{'workers'}  || 1;

	$autokill    = helper_prefix_if_exists("--autokill=", $gconf{'validation'}{'autokill'});
	$run_w       = helper_prefix_if_exists("--launcher=$internaldir/launchers/", $gconf{'validation'}{'run_wrapper'});
	$compil_w    = helper_prefix_if_exists("--compil-launcher=$internaldir/launchers/", $gconf{'validation'}{'compil_wrapper'});
	$compil_w    = helper_prefix_if_exists("--compil-launcher=$internaldir/launchers/", $gconf{'validation'}{'run_wrapper'}) if(!defined $compil_w);
	$verbosity   = helper_prefix_if_exists("--verbosity=", $gconf{'verbose'});
	$policy      = helper_prefix_if_exists("--policy=", $gconf{'validation'}{'sched_policy'});
	$maxjobt     = helper_prefix_if_exists("--maxt-job=", $gconf{'validation'}{'job_meantime'});
	$max_workert = helper_prefix_if_exists("--maxt-slave=", $gconf{'validation'}{'worker_maxtime'});
	$min_workert = helper_prefix_if_exists("--mint-slave=", $gconf{'validation'}{'worker_mintime'});
	$rc_on_fail  = ($gconf{'validation'}{'expect-success'}) ? "--expect-success" : "";

	my @list = `find $buildir/test_suite/ -name 'list_of_tests.xml'`; chomp @list;
	$test_files = join(" ", @list);

	my $command = "$buildir/tmp/bin/jchronoss --long-names --nb-resources=$nb_resources --nb-slaves=$nb_workers --build=$buildir/tmp $run_w $compil_w $autokill $verbosity $policy $max_workert $min_workert $rc_on_fail $maxjobt $test_files";

	#print($command."\n");
	system($command);
	my $ret = $? >> 8;
	if($ret != 0 and $rc_on_fail)
	{
		print "Aborting Validation due to failed results (expect-success requirement)\n";
		exit $ret;
	}
}


###########################################################################
#### MAIN
###########################################################################
$SIG{INT} = "trap_signal";

##### DEFAULT VALUES
$gconf{'regen'} = 1;
$gconf{'color'} = 0;
$gconf{'verbose'} = 0;
$gconf{'src'} = $srcdir;
$gconf{'build'} = $srcdir."/build";

# Read the command-line configuration
GetOptions (
	\%gconf,
	"config-target=s",
	"list-configs",
	"build=s",
	"select=s@",
	"compiler-target=s",
	"runtime-target=s",
	"group-target=s",
	"target=s",
	"log!",
	"list-directories",
	"list-runtimes",
	"list-compilers",
	"list-groups",
	"list-vars",
	"regen!",
	"color|c!",
	"expect-success",
	"verbose:i",
	"engine-debug",
	"h",
	"man",
	"help"

)  or die("Abort due to error(s) while parsing arguments (see --help)!\n");

# set $buildir depending on environment
$gconf{'build'} = helper_convert_absolute($gconf{'build'}, $CWD);
$gconf{testbuild} = "$gconf{build}/test_suite";
$buildir = $gconf{'build'};

pod2usage({-exitval => 0, -verbose => 0}) if($gconf{h});
pod2usage({-exitval => 0, -verbose => 1}) if($gconf{help});
pod2usage({-exitval => 0, -verbose => 2}) if($gconf{'man'});

# init the helper
helper_init(\%gconf);

# if options just ask for listing, do it and stop
exit(0) if helper_do_not_run_validation();

# create $buildir tree if not exist (without cleaning it)
helper_clean_path($buildir, 0);

my $validation_start = time();

# Parse configuration files (default and user)
configuration_init(%gconf);
%gconf = configuration_build();

# If just listing available vars, do it and stop (cannot be done earlier
# because the configuration needs to be loaded for it
if(exists $gconf{'list-vars'}) { configuration_display_vars();  exit(0); }

# if user wants to log the output (by default)
tee(STDOUT, '>', "$buildir/output.log") if (!exists $gconf{'log'} || $gconf{'log'});

print `cat $internaldir/resources/banners/test_suite_banner`;
print_summary();

# ready to go !
run_prepare();
run_configure() if($gconf{'regen'}); # this can be skipped to avoid overhead with slow FS
run_exec();
run_finalize();

my ($d, $h, $m, $s) = helper_convert_time(time()-$validation_start);
print "\n==> Validation completed in $d day(s), $h hour(s), $m minute(s) and $s second(s))\n";


=pod #Documentation start

=encoding utf-8

=head1 NAME

run_validation - Parallel Computing Validation Suite launcher

=head1 SYNOPSIS

run_validation [ --help ] [options] [--select=<directory>] 

Main Options (see --help or --man for further details):

    --select            Pick directories to build
    --config-target     Select configuration file to load.
    --runtime-target    Select runtime file to load.
    --compiler-target   Select compiler file to load.
    --help              Print argument-oriented help.
    --man               Print complete script documentation.

=head1 DESCRIPTION

=head1 OPTIONS

=head2 Selection Arguments

=over 4

=item --select

=item --config-target

=item --group-target

=item --compiler-target

=item --runtime-target

=item --target

=back

=head2 Global Arguments

=over 4

=item --build

=item --expect-success

=item --[no]log

=item --[no]regen

=item --[no]color, -[no]c

=item --verbose

=item --engine-debug

=item -h

Print condensed help menu (SYNOPSIS).

=item -help

Print each argument and a short description about them.

=item -man

Print the complete documentation 

=back

=head2 Listing Arguments

=over 4

=item --list-directories

=item --list-runtimes

=item --list-configs

=item --list-compilers

=item --list-groups

=item --list-vars

=back

=head1 AUTHOR

See the F<AUTHORS> file for contributors to PCVS.

=head1 BUGS

In case of troubles or questions with this software or the attached documentation, please address your request to the maintainers. You can found the complete list in the F<AUTHORS> file.

=head1 COPYRIGHT

Copyright (c) 2016,

Commissariat à l'Énergie Atomique et aux Énergies Alternatives (CEA)

This library is free software; you may redistribute it and/or modify it under the terms of the GNU General Public License (GPL) Version 2 or any later version.



=cut #Documentation end
